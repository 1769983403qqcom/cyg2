<?xml version="1.0" encoding="utf8"?>
<root>
	<item type="dict">
		<title type="str">画布 1</title>
		<topic type="dict">
			<title type="str">系统编程&amp; 进程线程管理</title>
			<topics type="list">
				<item type="dict">
					<title type="str">创建进程</title>
					<topics type="list">
						<item type="dict">
							<title type="str">fork</title>
							<topics type="list">
								<item type="dict">
									<title type="str">父进程创建子进程</title>
									<topics type="list">
										<item type="dict">
											<title type="str">子进程获得父进程的栈,数据段, 堆,代码段</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">一次调用,两次返回,父子进程都从fork处返回.</title>
									<topics type="list">
										<item type="dict">
											<title type="str">执行顺组无法保证</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">共享</title>
									<topics type="list">
										<item type="dict">
											<title type="str">文件句柄</title>
											<topics type="list">
												<item type="dict">
													<title type="str">指向同一个文件句柄, 共享同一个文件偏移</title>
												</item>
												<item type="dict">
													<title type="str">但是依然需要同步机制 写相同的文件. 同时追加写文件,不会互相覆盖</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">代码段</title>
											<topics type="list">
												<item type="dict">
													<title type="str">指向相同的物理页</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">数据段</title>
											<topics type="list">
												<item type="dict">
													<title type="str">基于写时复制, 避免fork复制大量内存</title>
												</item>
												<item type="dict">
													<title type="str">包括stdio等用户态数据缓冲池. 所以在 fork前,最好fflush</title>
												</item>
											</topics>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">execve</title>
							<topics type="list">
								<item type="dict">
									<title type="str">指定某个路径的可执行程序,执行, 并替换该进程的代码段, 堆栈等.</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">进程终止</title>
					<topics type="list">
						<item type="dict">
							<title type="str">exit执行动作</title>
							<topics type="list">
								<item type="dict">
									<title type="str">调用退出钩子程序(atexit, on_exit程序)</title>
								</item>
								<item type="dict">
									<title type="str">刷新Stdio缓冲区</title>
								</item>
								<item type="dict">
									<title type="str">调用_exit</title>
								</item>
								<item type="dict">
									<title type="str">不要使用return 退出, return退出的实现 没有规范, 实际也会调用exit但是status返回值不确定</title>
								</item>
								<item type="dict">
									<title type="str">关闭信号量, mmap的映射</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">_exit是系统调用, exit是c函数库</title>
						</item>
						<item type="dict">
							<title type="str">可通过信号处理函数,注册某个信号处理.</title>
							<topics type="list">
								<item type="dict">
									<title type="str">可忽略</title>
								</item>
								<item type="dict">
									<title type="str">可重新抛出</title>
								</item>
								<item type="dict">
									<title type="str">信号处理函数中如果使用系统调用,可能会覆盖全局错误no. 所以需要 在信号处理入口处, 保存errno.然后返回时,恢复errno</title>
								</item>
								<item type="dict">
									<title type="str">信号处理函数发生在系统调用即将返回时, 有自己的中断上下文</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">僵尸进程</title>
							<topics type="list">
								<item type="dict">
									<title type="str">子进程退出后,虽然会释放该进程的申请的资源,但是为了保证父进程可以通过wait获取到该子进程退出时(死因),依然会在内核进程表中记录该进程的一条记录. 标识其中止状态.资源使用数据等.</title>
								</item>
								<item type="dict">
									<title type="str">父进程调用wait信息之后, 内核会将该信息清除.如果父进程没有调用wait就退出了. 则init会自动调用wait</title>
								</item>
								<item type="dict">
									<title type="str">如果父进程不管这些僵尸进程,则内核的进程表会膨胀.</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">子进程退出时,会给父进程发送SIGCHILD信号.</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">监控进程</title>
					<topics type="list">
						<item type="dict">
							<title type="str">waitpid</title>
							<topics type="list">
								<item type="dict">
									<title type="str">指定某个子进程,所有子进程, 任意一个子进程的结束</title>
								</item>
								<item type="dict">
									<title type="str">可以获取进程如何退出的, 是通过exit, 信号灯</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">clone </title>
					<topics type="list">
						<item type="dict">
							<title type="str">和fork一样创建新进程,但是参数更多,可以创建轻型进程 -&gt; 线程</title>
							<topics type="list">
								<item type="dict">
									<title type="str">和fork使用同一个函数实现do_fork</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">包括参数</title>
							<topics type="list">
								<item type="dict">
									<title type="str">执行子函数 </title>
								</item>
								<item type="dict">
									<title type="str">进程栈</title>
									<topics type="list">
										<item type="dict">
											<title type="str">通过clone 创造线程， 怎么在线程退出后回收栈空间</title>
											<makers type="list">
												<item type="str">priority-1</item>
												<item type="str">flag-red</item>
												<item type="str">symbol-question</item>
											</makers>
											<topics type="list">
												<item type="dict">
													<title type="str">没有额外的信号通知机制告诉一个线程,某个线程退出</title>
												</item>
												<item type="dict">
													<title type="str">只有阻塞的join.显然不太合适</title>
												</item>
												<item type="dict">
													<title type="str">答案</title>
													<topics type="list">
														<item type="dict">
															<title type="str">一个是通过创建线程的线程join , 然后得到线程退出, 释放栈</title>
															<topics type="list">
																<item type="dict">
																	<title type="str">只能有被一个线程join. 也只应该被join一次. </title>
																</item>
																<item type="dict">
																	<title type="str">不一定只有创建线程才可以join,其他线程也可以.</title>
																</item>
																<item type="dict">
																	<title type="str">如果该线程既没有被join,也没有被detach,会成为僵尸线程.</title>
																	<topics type="list">
																		<item type="dict">
																			<title type="str">始终记住linux不区分进程线程.,,一视同仁</title>
																		</item>
																	</topics>
																</item>
															</topics>
														</item>
														<item type="dict">
															<title type="str">释放过程</title>
															<topics type="list">
																<item type="dict">
																	<title type="str">（1） 将栈内存块从 stack_used 取下放入 stack_cache 列表中。
(2) 释放 stack_cache 中已结束线程的栈内存块。这里是否已结束是根据 pthread tid 位是否被清零来业判断的。(3) 线程结束时， 由内核清除标志位（tid）， 这一步骤是由内核完成的，当线程结束时，内核会自动将tid清零，这就意味着一旦 tid 被清零就意味着线程已经结束</title>
																</item>
																<item type="dict">
																	<title type="str">线程会自己检查如果本线程被分离了,则自动为其释放栈信息等.</title>
																	<topics type="list">
																		<item type="dict">
																			<title type="str">线程clone的子函数 是对用户传入的子函数再次封装</title>
																		</item>
																		<item type="dict">
																			<title type="str">exit会直接退出进程. 这种场景不需要处理, 那么用户传入的子函数一定是return返回的,一定可以执行到
Glibc的清理部分.</title>
																		</item>
																	</topics>
																</item>
																<item type="dict">
																	<title type="str">如何detach</title>
																	<topics type="list">
																		<item type="dict">
																			<title type="str">（1）在线程创建时将其属性设为分离状态(detached)；</title>
																		</item>
																		<item type="dict">
																			<title type="str">（2）在线程创建后将其属性设为分离的(detached)。</title>
																		</item>
																		<item type="dict">
																			<title type="str">detach后的线程不应该被调用join</title>
																		</item>
																	</topics>
																</item>
															</topics>
														</item>
													</topics>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">向下增长,一般的数组访问都是++. 栈的访问都是--,所以传递给栈的数组地址
是高位地址.</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">参数</title>
								</item>
								<item type="dict">
									<title type="str">ptid, tls, ctid</title>
								</item>
								<item type="dict">
									<title type="str">flags</title>
									<topics type="list">
										<item type="dict">
											<title type="str">可共享打开描述符,共享IO 上下文, 命名空间, 挂载命名空间, 描述线程本地存储. 共享虚拟内存</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">线程共享了哪些东西</title>
							<topics type="list">
								<item type="dict">
									<title type="str">文件描述符</title>
								</item>
								<item type="dict">
									<title type="str">文件系统</title>
								</item>
								<item type="dict">
									<title type="str">信号处理函数也是共享的</title>
								</item>
								<item type="dict">
									<title type="str">共享虚拟内存</title>
									<topics type="list">
										<item type="dict">
											<title type="str">mmap, munmap</title>
										</item>
										<item type="dict">
											<title type="str">不同于fork的写实拷贝</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">线程组</title>
									<topics type="list">
										<item type="dict">
											<title type="str">共享同一个进程ID </title>
											<topics type="list">
												<item type="dict">
													<title type="str">也就是线程组ID</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">每个线程有自己的TID </title>
											<topics type="list">
												<item type="dict">
													<title type="str">getTID ,java的tid不是自创的.</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">线程组首个线程TID 和进程TGID 相同</title>
										</item>
										<item type="dict">
											<title type="str">任何一个线程执行了exec, 都会终止其他线程,而本线程成为新进程的首个线程.</title>
										</item>
										<item type="dict">
											<title type="str">如果任何一个子线程调用了fork创建子线程,那么其他线程都可以使用waitpid监控该线程</title>
										</item>
										<item type="dict">
											<title type="str">一个子线程退出并不是发送特殊的信号给主线程,当所有的子线程都推出时,才会发送SIGCHILD信号</title>
										</item>
										<item type="dict">
											<title type="str">pthread_join</title>
											<topics type="list">
												<item type="dict">
													<title type="str">一个线程通过监测某一个线程ctid (线程id的存储地址),得到ctid变化的通知</title>
												</item>
												<item type="dict">
													<title type="str">线程退出时,会修改该位置, 并通知其他其他线程wake. 解除阻塞</title>
												</item>
											</topics>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">线程和进程</title>
									<topics type="list">
										<item type="dict">
											<title type="str">只是对资源的共享程度不同而已</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">可共享同一挂载地址空间.</title>
									<topics type="list">
										<item type="dict">
											<title type="str">linux支持为每一个进程设置根目录地址</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">控制终端</title>
								</item>
								<item type="dict">
									<title type="str">nice,errno, 实时调度策略, 优先级, cpu亲和力</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">线程局部变量</title>
					<topics type="list">
						<item type="dict">
							<title type="str">变量声明中有__thread .</title>
							<topics type="list">
								<item type="dict">
									<title type="str">static __thread buf[MAX_LEN]</title>
								</item>
								<item type="dict">
									<title type="str">需要linux内核, 线程库, (NPTL), C编译器同时支持.(否则无法实现)</title>
								</item>
								<item type="dict">
									<title type="str">errno就是使用了线程本地存储</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">多进程&amp;多线程</title>
					<topics type="list">
						<item type="dict">
							<title type="str">fork</title>
							<topics type="list">
								<item type="dict">
									<title type="str">需要拷贝内存页表, 文件描述符表</title>
								</item>
								<item type="dict">
									<title type="str">线程clone不需要管这些</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">线程比进程创建快速十倍</title>
						</item>
					</topics>
				</item>
			</topics>
		</topic>
		<structure type="str">org.xmind.ui.map.clockwise</structure>
	</item>
</root>
