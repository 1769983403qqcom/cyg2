<?xml version="1.0" encoding="utf8"?>
<root>
	<item type="dict">
		<title type="str">画布 1</title>
		<topic type="dict">
			<title type="str">mysql</title>
			<topics type="list">
				<item type="dict">
					<title type="str">淘气三千问</title>
					<topics type="list">
						<item type="dict">
							<title type="str">mysql 如何保证宕机不丢数据 的同时保证高性能?</title>
						</item>
						<item type="dict">
							<title type="str">mysql binlog 主从延迟的影响因素有哪些, 哪些做法可以减少主从延迟?</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">mvcc 机制</title>
					<topics type="list">
						<item type="dict">
							<title type="str">实现原理</title>
							<topics type="list">
								<item type="dict">
									<title type="str">通过保存数据在某个时间点的快照来实现的</title>
								</item>
								<item type="dict">
									<title type="str">通过在每行记录后面保存2个隐藏的列来实现的,一列保存了行的创建时间,一列保存了行的过期时间(或删除时间).但他们都存储的是系统版本号.</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">对 SQL影响</title>
							<topics type="list">
								<item type="dict">
									<title type="str">select</title>
									<topics type="list">
										<item type="dict">
											<title type="str">1, InnoDB只查找版本早于当前事务版本的数据行(行的系统版本号小于等于事务的系统版本号)</title>
										</item>
										<item type="dict">
											<title type="str">2, 行的删除号要么未定义,要么大于当前事务版本号,这样可以确保事务读取到的行,在事务开始之前未被删除.</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">insert</title>
									<topics type="list">
										<item type="dict">
											<title type="str">为新插入的每一行保存当前系统版本号做为行版本号</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">delete</title>
									<topics type="list">
										<item type="dict">
											<title type="str">为删除的每一行保存当前系统版本号作为行删除标识</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">update</title>
									<topics type="list">
										<item type="dict">
											<title type="str">插入的每一行新记录,保存当前系统版本号作为行版本号,同时保存当前系统版本号到原来的行作为行删除标识</title>
										</item>
										<item type="dict">
											<title type="str">这样select 在查询时,要保证查询的版本号小于行 删除版本号.</title>
										</item>
										<item type="dict">
											<title type="str">copy on update</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">引擎层和 server 的区别</title>
				</item>
				<item type="dict">
					<title type="str">隔离级别</title>
					<topics type="list">
						<item type="dict">
							<title type="str">innodb 默认解决了 幻读问题</title>
						</item>
						<item type="dict">
							<title type="str">执行过程中中断</title>
							<topics type="list">
								<item type="dict">
									<title type="str">innodb: 如果执行 update,delete 过程中及时中断,不会导致事务提交(即不会生效)</title>
								</item>
								<item type="dict">
									<title type="str">myinsm: 由于没有事务的概念,执行到哪里算哪里</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">存储及落盘原理</title>
					<topics type="list">
						<item type="dict">
							<title type="str">INNODB_FLUSH_METHOD</title>
							<topics type="list">
								<item type="dict">
									<title type="str">innodb_flush_method指定的不仅是“数据文件”的刷新方式，也指定了“日志文件”刷新方式。</title>
								</item>
								<item type="dict">
									<title type="str">四种选择</title>
									<topics type="list">
										<item type="dict">
											<title type="str"> fdatasync</title>
										</item>
										<item type="dict">
											<title type="str">O_DSYNC</title>
										</item>
										<item type="dict">
											<title type="str">O_DIRECT</title>
										</item>
										<item type="dict">
											<title type="str">O_DIRECT_NO_FSYNC</title>
											<topics type="list">
												<item type="dict">
													<title type="str">之前使用O_DIRECT 还需要fsync同步元数据,最新版本的内核不需要了,DIRECT可以安全的刷新元数据到磁盘</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">前三个参数值只允许在5.6.6和5.6.6之前的版本中用，从5.6.7开始新增了O_DIRECT_NO_FSYNC</title>
										</item>
										<item type="dict">
											<title type="str">四个参数设置的结果</title>
											<topics type="list">
												<item type="dict">
													<title type="str">如果innodb_flush_method设置了O_DSYNC，日志文件(ib_logfileXXX)使用O_SYNC打开，因此写完数据不需要调用函数fsync刷盘，数据文件(ibd)使用default模式打开，因此写完数据需要调用fsync刷盘。</title>
												</item>
												<item type="dict">
													<title type="str">如果innodb_flush_method设置了O_DIRECT，日志文件(ib_logfileXXX)使用default模式打开，写完数据需要调用fsync函数刷盘，数据文件(ibd)使用O_DIRECT模式打开，写完数据需要调用fsync函数刷盘。此时fsync刷新元数据.</title>
												</item>
												<item type="dict">
													<title type="str">如果innodb_flush_method设置了fsync或者不设置，数据文件和日志文件都使用default模式打开，写完数据都需要使用fsync来刷盘。</title>
												</item>
												<item type="dict">
													<title type="str">如果innodb_flush_method设置为O_DIRECT_NO_FSYNC，文件打开方式与O_DIRECT模式类似，区别是，数据文件写完后，不调用fsync函数来刷盘，主要针对O_DIRECT能保证文件的元数据也落盘的文件系统。 InnoDB</title>
												</item>
												<item type="dict">
													<title type="str">目前还不支持使用O_DIRECT模式打开日志文件，也不支持使用O_SYNC模式打开数据文件。
所以指定DIRECT 就是指定打开数据文件, 指定SYNC 就是指定日志文件. 不设置都是使用page cache</title>
													<makers type="list">
														<item type="str">task-done</item>
														<item type="str">priority-1</item>
														<item type="str">flag-red</item>
													</makers>
												</item>
												<item type="dict">
													<title type="str">日志文件需要及时落盘. 数据文件可以使用缓存. 也可以使用直接IO ,但是不能使用SYNC及时刷新page cahe的方式</title>
												</item>
											</topics>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">保证对文件写的独占</title>
							<topics type="list">
								<item type="dict">
									<title type="str">InnoDB使用了文件系统的文件锁来保证只有一个进程对某个文件进行读写操作</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">线程模型</title>
					<topics type="list">
						<item type="dict">
							<title type="str">master 线程</title>
							<topics type="list">
								<item type="dict">
									<title type="str">负责将缓冲池中的数据异步刷新到磁盘. 例如脏页, 合并插入缓冲, </title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">io线程</title>
							<topics type="list">
								<item type="dict">
									<title type="str">可分别设置读写个数</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">purge 线程</title>
							<topics type="list">
								<item type="dict">
									<title type="str">回收undo 页</title>
									<topics type="list">
										<item type="dict">
											<title type="str">事务结束之后, undo页可能就不需要,需要检查并回收</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">page cleaner 线程</title>
							<topics type="list">
								<item type="dict">
									<title type="null"/>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">缓冲</title>
					<topics type="list">
						<item type="dict">
							<title type="str">任何缓冲都会存在最基本的修改单元,对于流的缓冲,例如管道, 文件输出流, 最小的单位是字节. 但是对于修改已经存在的数据, 尤其是结构化的数据, 有具体的组织方式的数据, 最小的缓冲单元 绝对不是字节, 因为无法控制一个个字节 的写会磁盘.  一般都按照最小的存储单元, 例如操作系统page cache 是按照操作系统页大小组织4k, 而mysql 也存在这种组织方式, 也是按照页, 这个页直接存储具体的行记录, 每次刷新都是刷新这个页. 而不是页中的某个具体的字节.</title>
							<makers type="list">
								<item type="str">task-done</item>
								<item type="str">flag-red</item>
								<item type="str">priority-1</item>
							</makers>
						</item>
						<item type="dict">
							<title type="str">此处的缓冲都是 mysql 用户态 的缓冲</title>
						</item>
						<item type="dict">
							<title type="str">lru列表</title>
							<topics type="list">
								<item type="dict">
									<title type="str">为了避免瞬时的全量查询 污染lru,而采用两段lru ,即热点数据lru,和普通lru 先进入普通lru,只有多长时间没有淘汰,才会被放到热点数据lru. 可以避免 偶然的大量表扫描, 清空热点数据</title>
								</item>
								<item type="dict">
									<title type="str">被lru刷出的页需要写入到磁盘</title>
									<topics type="list">
										<item type="dict">
											<title type="str">此时该脏页对应的redo log对应的check point如何同步</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">重做日志缓冲</title>
							<topics type="list">
								<item type="dict">
									<title type="str">大约8M.</title>
								</item>
								<item type="dict">
									<title type="str">每个事务提交会刷新缓冲, master thread 会将重做日志缓冲池刷新到文件, 重做日志缓冲池小于1/2时,刷新缓冲池</title>
								</item>
								<item type="dict">
									<title type="str">写入到磁盘并不代表 会被写入到磁盘, 还会由其他的参数来保证何时将内核缓冲的数据刷新到磁盘.但是每个事务结束后,会将日志刷新到文件. 所以不会存在重做日志缓冲池 脏的问题. 或者说,重做日志中的数据 都是未提交的数据</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">插入缓冲</title>
							<topics type="list">
								<item type="dict">
									<title type="str">当表中存在多个索引时, 除了主键的聚簇索引 可能由于自增主键递增. 这时插入都是顺序插入. 对于其他辅助索引, 例如字符串, 就是随机插入索引了. 这样在新增记录时, 多个索引就会插入多次,严重降低速度.  
mysql 采用插入缓冲 优化这个问题, 每次索引页插入都优先插入到 缓冲. </title>
								</item>
								<item type="dict">
									<title type="str">使用条件</title>
									<topics type="list">
										<item type="dict">
											<title type="str">索引时辅助索引,非聚簇主键索引</title>
										</item>
										<item type="dict">
											<title type="str">索引不是唯一的</title>
											<topics type="list">
												<item type="dict">
													<title type="str">唯一索引不能使用插入缓冲, 需要查询索引检索是否唯一</title>
												</item>
											</topics>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">change buffer</title>
							<topics type="list">
								<item type="dict">
									<title type="str">delete buffer</title>
									<topics type="list">
										<item type="dict">
											<title type="str">删除先缓存中加标记.</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">致命的脏页回写问题.</title>
					<topics type="list">
						<item type="dict">
							<title type="str">innodb 每页大小16k,大于每次磁盘操作块的大小512b. 如何保证在写页的时候发生崩溃,不会导致数据损坏呢?加入如果16k,只写了4k,那么这个页就是损坏的. 那么redo log在对一个页进行崩溃重做时,由于该页 并不是完全没有同步数据, 而是同步了一半, 那么重做日志也无能为力, 因为重做日志只是记录了该页的变更,而不是该页的镜像副本. 所以为了保证这个问题. innodb 采用了双写保证这个问题</title>
						</item>
						<item type="dict">
							<title type="str">双写解决写缓冲半写 崩溃问题.</title>
							<topics type="list">
								<item type="dict">
									<title type="str">首先脏页回写前 先复制该页数据 到double write buffer, 而后将buffer顺序写入到物理磁盘的文件上.并强制刷新内核缓冲保证落盘. 此时double write buffer可以存储64个页. 也就是64个脏页. 这64个脏页数据用磁盘进行备份.</title>
								</item>
								<item type="dict">
									<title type="str">而后脏页回写. 此时脏页回写的过程中, 会出现随机读写, 因为mysql的64个页. 涉及到的表空间,段都会不同. 但是double write buffer写磁盘是顺序的(只是顺序备份而已). </title>
								</item>
								<item type="dict">
									<title type="str">如果崩溃了, 此时写得页都是半写脏数据, 如果想使用redo log 重做. 需要首先对该页 进行恢复,因为该页是半写的, 此时double write buffer 写入的文件就可以起作用了. </title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">innodb使用double write buffer 保证了脏页半写崩溃问题, 同时又保证了效率 , 每次顺序写64个脏页进行备份.</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">参数调优</title>
				</item>
				<item type="dict">
					<title type="str">update 更新问题</title>
					<topics type="list">
						<item type="dict">
							<title type="str">相同的记录修改</title>
							<topics type="list">
								<item type="dict">
									<title type="str">binlog_format=statement和binlog_row_image=FULL时，InnoDB内部认真执行了update语句，即“把这个值修改成 (1,999)“这个操作，该加锁的加锁，该更新的更新</title>
								</item>
								<item type="dict">
									<title type="str">在binlog_format=row和binlog_row_image=FULL时，由于MySQL 需要在 binlog 里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来，那么重复数据的update不会执行</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">innodb 逻辑存储结构</title>
					<topics type="list">
						<item type="dict">
							<title type="str">表空间</title>
							<topics type="list">
								<item type="dict">
									<title type="str">可以将表放入共享表空间,也可以指定每个表一个空间</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">段</title>
							<topics type="list">
								<item type="dict">
									<title type="str">数据段, 索引段, 插入缓冲Bitmap, 回滚段, 插入缓冲索引页, 系统事务信息, 二次写缓冲.</title>
								</item>
								<item type="dict">
									<title type="str">数据段即为B+ 数的叶子节点, 索引段而B+树的索引字段.</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">区</title>
							<topics type="list">
								<item type="dict">
									<title type="str">区由连续页组成, 大小为1M. </title>
									<makers type="list">
										<item type="str">task-done</item>
										<item type="str">flag-red</item>
										<item type="str">priority-1</item>
									</makers>
									<topics type="list">
										<item type="dict">
											<title type="str">磁盘连续哦</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">页</title>
							<topics type="list">
								<item type="dict">
									<title type="str">默认页大小16K,  每个段在开始时,使用32个碎片页 存储,为了避免每个表(如果每个表都是一个空间)都申请1M 的区.</title>
								</item>
								<item type="dict">
									<title type="str">包括数据页, undo页, 系统页, 事务数据页, 插入缓冲位图页, 插入缓冲空闲列表页, 未压缩的二进制大对象页, 压缩的二进制大对象(BLOB, TEXT)页</title>
								</item>
								<item type="dict">
									<title type="str">varchar 最大字节是65536. 每行的所有varchar最大字节是65536.</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">redo log &amp;  bin log 一致性</title>
					<topics type="list">
						<item type="dict">
							<title type="str">[Image]</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">事务日志</title>
					<topics type="list">
						<item type="dict">
							<title type="str">binlog</title>
							<topics type="list">
								<item type="dict">
									<title type="str">sync_binlog</title>
									<topics type="list">
										<item type="dict">
											<title type="str">执行几次事务将binlog刷新到磁盘</title>
										</item>
										<item type="dict">
											<title type="str">sync_binlog选项控制mysql怎么刷新二进制日志到磁盘，默认是0，意味着mysql并不刷新，由操作系统自己决定什么时候刷新缓存到持久化设置，如果</title>
										</item>
										<item type="dict">
											<title type="str">这个值比0大，它指定了两次刷新到磁盘的动作之间间隔多少次二进制日志写操作</title>
										</item>
										<item type="dict">
											<title type="str">在事务开始时,会将binlog 写到内存缓冲, 在提交时, 写入到磁盘文件. 至于何时刷新内核缓冲到磁盘文件🈶sync_binlog控制</title>
											<makers type="list">
												<item type="str">priority-1</item>
												<item type="str">task-done</item>
												<item type="str">flag-red</item>
											</makers>
										</item>
										<item type="dict">
											<title type="str">为 0</title>
											<topics type="list">
												<item type="dict">
													<title type="str">表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。这时候的性能是最好的，但是风险也是最大的。</title>
												</item>
												<item type="dict">
													<title type="str">因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">即使每次提交都刷新内核缓冲, 但是考 bin log 的成功写入和 数据文件的commit成功写入还是存在一致性问题.依赖于innodb_support_xa解决</title>
										</item>
										<item type="dict">
											<title type="str">binlog_do_db &amp; binlog_ignore_db 表示写入和忽略写入哪些库</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str"> Mysql binlog日志有三种格式</title>
									<topics type="list">
										<item type="dict">
											<title type="str">Statement：每一条会修改数据的sql都会记录在binlog中</title>
											<topics type="list">
												<item type="dict">
													<title type="str">不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能</title>
												</item>
												<item type="dict">
													<title type="str">由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">2）Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改</title>
											<topics type="list">
												<item type="dict">
													<title type="str">基于row格式,可以将隔离级别设置为read committed, 如果基于statement 则会出现丢失更新现象.导致主从数据不一致. 还没搞清楚为啥</title>
												</item>
												<item type="dict">
													<title type="str">自增主键会被自动设置为具体的值</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">Mixedlevel: 是以上两种level的混合使用</title>
											<topics type="list">
												<item type="dict">
													<title type="str">一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。</title>
												</item>
											</topics>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">binlog 和表结构.frm文件都是mysql server层的数据, 和存储引擎无关</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">redo log</title>
							<topics type="list">
								<item type="dict">
									<title type="str">重做日志(包括内存中的redo log buffer, 和磁盘上的redo log file), 用来保证事务的原子性和持久性, 恢复提交事务修改的页操作</title>
								</item>
								<item type="dict">
									<title type="str">redo log可以保证事务在commit 时,将该事务的所有修改操作引起的日志写入到redo log, 写入操作都是顺序写的.在数据库查询 写入等sql操作时,不需要对redo log进行读取.</title>
								</item>
								<item type="dict">
									<title type="str">重做日志不能使用直接IO , 需要使用内核缓冲区, 所以需要使用fsync同步内核缓冲区到磁盘文件(也可以依赖于内核的自动刷新机制,但是不及时)</title>
								</item>
								<item type="dict">
									<title type="str">由于重做日志是以磁盘块大小进行组织的, 每个重做日志块都是512字节, 如果一个页产生了大于512字节的重做日志,需要切块, 每个块还包括日志头,尾巴(12字节) </title>
								</item>
								<item type="dict">
									<title type="str">如何控制重做日志何时刷新到磁盘上</title>
									<topics type="list">
										<item type="dict">
											<title type="str">innodb_flush_log_at_trx_commit</title>
											<topics type="list">
												<item type="dict">
													<title type="str">默认值是1</title>
													<topics type="list">
														<item type="dict">
															<title type="str">每次提交事务都会fsync将重做日志刷新到磁盘</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">0 代表事务提交时,不刷新日志到磁盘, 而是由mysql master 线程每隔1s 刷新到磁盘.</title>
												</item>
												<item type="dict">
													<title type="str">2代表完全不由mysql控制 重做日志的内核缓冲刷新策略,而是由操作系统决定, 默认操作系统在物理内存不足时,或者每隔30s刷新一次</title>
												</item>
												<item type="dict">
													<title type="str">这个参数设置和innodb_flush_method指定不冲突, 日志文件一定不会使用直接IO,所以一定需要fsync函数的调用.但是DSYNC 确实是每次指定都刷新内核缓冲</title>
												</item>
												<item type="dict">
													<title type="str">指定0的模式比指定内核刷新策略的速度 更快,大约是两倍速度, 是每次事务都刷新磁盘速度的十倍.</title>
												</item>
											</topics>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">	何时刷新redo log的check point</title>
									<topics type="list">
										<item type="dict">
											<title type="str">即何时将用户态的数据缓冲池 落盘, redo log是保证崩溃恢复,但是如果数据落盘 redo 就可以删除, 可以指定redo log的水位为75% ,如果redo log最大2G, 那么redo log为1.5G, 就会刷新数据缓冲区, 同时清理redo log,可以把redo log指示为多少 缓冲数据 需要落盘, 但是redo log的大小,并不代表缓冲池的大小.(很简单redo log是页更变更的物理日志, 缓冲池记录的是数据)</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">作用: 用来崩溃恢复, innodb引擎在每次启动时都会检查redo log, 由于重做日志是物理日志, 比binlog 要快得多.redo log 是在每次事务提交都可能刷新到磁盘的,但是对于 mysql数据的修改, 并不一定及时的刷新到磁盘上.为了保证性能. mysql 通过日志保证再次 恢复一定不会丢数据, 而不是依赖于每次刷新数据问题.(刷新数据文件不一定是追加写,会涉及到随机写)</title>
								</item>
								<item type="dict">
									<title type="str">重做日志文件的大小使用innodb_log_file_size 设置, 随着数据文件刷新到磁盘, redo log会减少, 同时如果redo log限制太小, 会提前刷新数据文件到磁盘以回收redo log.(一定保证redo log被写入, 如果不够就清理,清理的方式就是刷新数据文件,这样redo log就没用了,可以被清理了). 如果redo log 太大,则崩溃恢复时间太长.</title>
								</item>
								<item type="dict">
									<title type="str">重做日志实例: 偏移量800 写aaaa记录</title>
								</item>
								<item type="dict">
									<title type="str">redo log 循环写 &amp;checkpoint</title>
									<topics type="list">
										<item type="dict">
											<title type="str">[Image]</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">undo log</title>
							<topics type="list">
								<item type="dict">
									<title type="str">undo log用来保证事务的一致性, undo 回滚行记录到某个特定版本, 用来帮助事务回滚及MVCC功能. 需要进行随机读写.</title>
								</item>
								<item type="dict">
									<title type="str">undo 存储在表空间中, 作为回滚段存在, 一个回滚段包括1024个undo log segment, undo 并不是将数据库物理的恢复到事务执行前. 而是逻辑上的恢复, 因为undo记录的并不是事务发生前的物理页面的镜像, 而是记录事务过程中,事务操作的反操作, 例如insert-&gt;delete, delete-&gt;insert .</title>
								</item>
								<item type="dict">
									<title type="str">undo log和redo log是不同的, undo log的修改也会产生redo log</title>
								</item>
								<item type="dict">
									<title type="str">undo log在事务完成后还有用吗? </title>
									<topics type="list">
										<item type="dict">
											<title type="str">有用的, undo log可以用来mvcc 支持事务多版本并发读, 会将所有已经提交的undo页 放入单独的链表,由purge 线程决定何时删除该undo 页</title>
										</item>
										<item type="dict">
											<title type="str">undo由于并不是在磁盘连续的(undo log其实也是数据部分,非redo log), 所以需要在单独的线程中处理, 离散的磁盘读取非常慢</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">undo log分为: insert  undo log, update undo log, insert undo log 不需要被其他事务访问(不可见, undo log并不是实际的数据, 实际数字在叶子节点), 可以直接删除,不需要purge. update undo log 需要考虑purge , 例如delete 需要考虑其他事务可能依然需要访问这条数据, update 也同样如此.</title>
								</item>
								<item type="dict">
									<title type="str">undo log在information_schema.INNODB_TRX_ROLLBACK_SEGMENT 表中</title>
								</item>
								<item type="dict">
									<title type="str">innodb_purge_batch_size 表示每次purge 操作需要清理的undo log,默认值为300, 太小undo log会占用太多磁盘来不及清理, 太大则磁盘io过大.一般不用改这个参数</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">redo日志和bin log的区别</title>
							<topics type="list">
								<item type="dict">
									<title type="str">redo log和bin log很类似, 但是有本质区别, relog 是innodb层提供的日志,而bin log 是对所有引擎都生效的日志,也就是mysql server层面产生的日志. 用来主从复制.</title>
								</item>
								<item type="dict">
									<title type="str">redo log记录的是对于物理设备每个页的修改. 而binlog记录的是对应的sql语句,或者对每行记录的修改</title>
								</item>
								<item type="dict">
									<title type="str">bin log在事务提交完成后进行一次写入, 而redo log在事务进行中不断被写入,一个事务可能对应多条重做日志, 重做日志在追加时,也是并发进行的. 重做日志的写入时间点不是在事务提交时, 但是确是在事务提交时,需要决定是否刷新到磁盘上.</title>
								</item>
								<item type="dict">
									<title type="str">重做日志是幂等的,即修改到什么值就是什么值,包括插入, 但是bin log不是幂等的.(insert 多次会插入多条)</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
			</topics>
		</topic>
		<structure type="str">org.xmind.ui.map.unbalanced</structure>
	</item>
</root>
