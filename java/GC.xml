<?xml version="1.0" encoding="utf8"?>
<root>
	<item type="dict">
		<title type="str">画布 1</title>
		<topic type="dict">
			<title type="str">GC</title>
			<topics type="list">
				<item type="dict">
					<title type="str">什么是堆栈,为什么要有堆栈之分</title>
				</item>
				<item type="dict">
					<title type="str">职责</title>
					<topics type="list">
						<item type="dict">
							<title type="str">分配内存</title>
						</item>
						<item type="dict">
							<title type="str">确保任何被引用的对象仍然在内存中间</title>
						</item>
						<item type="dict">
							<title type="str">重新覆盖那些在执行代码中引用不可达的内存</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">算法优劣</title>
					<topics type="list">
						<item type="dict">
							<title type="str">延时</title>
							<topics type="list">
								<item type="dict">
									<title type="str">并发度　= 吞吐量 * 延迟</title>
									<topics type="list">
										<item type="dict">
											<title type="str">吞吐和延时是两个单独的变量.吞吐可以通过加机器,提高并发解决.提高吞吐不一定延时增加,降低吞吐,延时不一定增加</title>
										</item>
										<item type="dict">
											<title type="str">要找到系统的瓶颈也就是影响并发的地方,这个地方是优化吞吐的关键.而延时可能包括:优化代码,异步处理等等</title>
										</item>
										<item type="dict">
											<title type="str">延时暂时不包括等待排队延时,只是任务实际处理的延迟,在实际的监控中,应该分离这两种监控, 实际上任务处理的耗时随着吞吐量可能不变, 但是等待耗时可能会变化,因为并发度如果到了瓶颈,请求量上去,延时不变,排队的请求会变多. 用户或者调用方感受到就是延迟增加</title>
										</item>
										<item type="dict">
											<title type="str">只针对一种请求或一个指标.不能把所有的请求都算上.这样结果可能有出入,因为不同接口的QPS和延时是不同的,
会出现因为某些请求突然增加减少,导致整体延时增加或者减少的情况</title>
										</item>
										<item type="dict">
											<title type="str">通过观察请求延时(包括排队)和处理延时,可以让我们看到实际的并发度.避免用户请求排队</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">占用CPU</title>
							<topics type="list">
								<item type="dict">
									<title type="str">并发还是串行</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">内存碎片</title>
							<topics type="list">
								<item type="dict">
									<title type="str">需要压缩</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">频繁程度</title>
						</item>
						<item type="dict">
							<title type="str">Stop the world</title>
							<topics type="list">
								<item type="dict">
									<title type="str">枚举根节点时需要禁止对象引用关系的变化,否则无法准确GC</title>
								</item>
								<item type="dict">
									<title type="str">JVM会在特定的数据结构中记录所有对象的引用关系</title>
								</item>
								<item type="dict">
									<title type="str">并不是线程的任何字节码指令执行时,都能被挂起,只有特定的某些地方,才可以挂起线程,暂停点</title>
								</item>
								<item type="dict">
									<title type="str">STW前需要暂停所有线程,所以 PrintGCApplicationStoppedTime jvm参数 会打印Stopping 线程所需要的时间</title>
								</item>
								<item type="dict">
									<title type="str">Java 线程模型采用 LWP 1:1 即一个线程映射为一个内核线程, 在函数进入退出, uncount loop(while) 循环等会专门有检查点, 检查点也就是有一条机器指令,访问某个内存页,该页为缺页时,就会触发一个中断信号, 线程转而需要执行该信号处理,即 停止执行</title>
									<topics type="list">
										<item type="dict">
											<title type="str">子主题 1</title>
											<topics type="list">
												<item type="dict">
													<title type="str"> Signal Dispatcher</title>
													<topics type="list">
														<item type="dict">
															<title type="str">信号处理分配器, linux  上的信号处理只能有一个线程处理</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">CompilerThread0</title>
													<topics type="list">
														<item type="dict">
															<title type="str">即时编译线程</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="null"/>
												</item>
												<item type="dict">
													<title type="str">Attach Listener</title>
													<topics type="list">
														<item type="dict">
															<title type="str">该线程负责接收外部命令，执行该命令并把结果返回给调用者
java -version</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">Reference Handler</title>
													<topics type="list">
														<item type="dict">
															<title type="str">JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">VM Thread</title>
													<topics type="list">
														<item type="dict">
															<title type="str">VM中线程的母体，根据HotSpot源码中关于vmThread.hpp里面的注释，它是一个单例的对象（最原始的线程）会产生或触发所有其他的线程，这个单例的VM线程是会被其他线程所使用来做一些VM操作（如清扫垃圾等）。</title>
														</item>
														<item type="dict">
															<title type="str">VM线程是HotSpot VM中的特殊线程。它在VM中执行特殊任务，例如垃圾收集</title>
														</item>
														<item type="dict">
															<title type="str">在 VM Thread 的结构体里有一个VMOperationQueue列队，所有的VM线程操作(vm_operation)都会被保存到这个列队当中，VMThread 本身就是一个线程，它的线程负责执行一个自轮询的loop函数(具体可以参考：VMThread.cpp里面的void VMThread::loop()) ，该loop函数从VMOperationQueue列队中按照优先级取出当前需要执行的操作对象(VM_Operation)，并且调用VM_Operation-&gt;evaluate函数去执行该操作类型本身的业务逻辑。</title>
														</item>
														<item type="dict">
															<title type="str">VM操作类型被定义在vm_operations.hpp文件内，列举几个：ThreadStop、ThreadDump、PrintThreads、GenCollectFull、GenCollectFullConcurrent、CMS_Initial_Mark、CMS_Final_Remark</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">VM Periodic Task Thread</title>
													<topics type="list">
														<item type="dict">
															<title type="str">该线程是JVM周期性任务调度的线程，它由WatcherThread创建，是一个单例对象。该线程在JVM内使用得比较频繁，比如：定期的内存监控、JVM运行状况监控。</title>
														</item>
														<item type="dict">
															<title type="str">例如 jstat,查看 内部监控</title>
															<topics type="list">
																<item type="dict">
																	<title type="null"/>
																</item>
															</topics>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">GC task thread</title>
													<topics type="list">
														<item type="dict">
															<title type="str">垃圾回收线程，该线程会负责进行垃圾回收。通常JVM会启动多个线程来处理这个工作</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">Concurrent Mark-Sweep GC Thread</title>
													<topics type="list">
														<item type="dict">
															<title type="str">并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于年老代垃圾回收</title>
														</item>
													</topics>
												</item>
											</topics>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">为什么</title>
									<topics type="list">
										<item type="dict">
											<title type="str">   1. 用户线程和 c mark 线程存在并发竞争.

     1.1A 独立, B 引用 C.  cmark先遍历了 A, cmark 线程遍历到 B 时, 用户线程将 C 给了 A.  这时候 C 没有被 reachable 到. 最后认为 C 是 unreable 的.其实并不是

    1.2. 另外已分配的池也时时变大. 如果不锁住,也会被有问题.导致 unreachable 计算的有误.</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">发生时机</title>
					<topics type="list">
						<item type="dict">
							<title type="str">新生代、年老代和永久代这三个空间中的任何一个不能满足内存分配请求时，就会发生垃圾收集</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">内存管理</title>
					<topics type="list">
						<item type="dict">
							<title type="str">内存组织</title>
							<topics type="list">
								<item type="dict">
									<title type="str">指针碰撞</title>
									<topics type="list">
										<item type="dict">
											<title type="str">使用一个指针记录空闲内存的起始地址,每次内存连续分配</title>
										</item>
										<item type="dict">
											<title type="str">ParNew, Serial垃圾回收都使用这种方式,使用标记复制算法的</title>
										</item>
										<item type="dict">
											<title type="str">为了避免线程同步,使用TLAB 线程局部存储空间 ,如果该内存不足,则使用 CAS算法,无锁同步申请内存</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">空闲链表</title>
									<topics type="list">
										<item type="dict">
											<title type="str">使用一个链表记录内存的空闲地址,内存分配并不是连续的</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">内存区域</title>
							<topics type="list">
								<item type="dict">
									<title type="str">MetaSpace元数据</title>
									<topics type="list">
										<item type="dict">
											<title type="str">非堆空间,是jvm从os 中申请的内存,可以动态扩展,不会参与垃圾回收</title>
										</item>
										<item type="dict">
											<title type="str">每一个类加载器都会对应一个元数据空间</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">根搜索算法</title>
							<topics type="list">
								<item type="dict">
									<title type="str">根节点</title>
									<topics type="list">
										<item type="dict">
											<title type="str">1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象 ； </title>
										</item>
										<item type="dict">
											<title type="str">2. 方法区中的类静态属性引用的对象 ； </title>
										</item>
										<item type="dict">
											<title type="str">3. 方法区中的常量引用的对象 ； </title>
										</item>
										<item type="dict">
											<title type="str">4. 本地方法栈中JNI的引用的对象； </title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">日志查看</title>
					<topics type="list">
						<item type="dict">
							<title type="str">real time指进程实际处理的时间.包括占用cpu  时间.i/o, 锁等待是 block,挂起时间</title>
						</item>
						<item type="dict">
							<title type="str">user time,sys time 是指进程处于用户态和内核态的 cpu时间.(不包括i/o 阻塞时间)</title>
						</item>
						<item type="dict">
							<title type="str">由于多线程情景的存在,进程的 real time 可能小于 user, sys time</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">排查工具</title>
					<topics type="list">
						<item type="dict">
							<title type="str">jstack -l pid</title>
						</item>
						<item type="dict">
							<title type="str">jmap -heap</title>
							<topics type="list">
								<item type="dict">
									<title type="str">dump 出当前进程的内存使用情况</title>
								</item>
								<item type="dict">
									<title type="str">会可能导致当前进程阻塞</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">jmap -histo 10953</title>
							<topics type="list">
								<item type="dict">
									<title type="str">查看类实例的柱状信息</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">参数</title>
					<topics type="list">
						<item type="dict">
							<title type="str">-XX:+PrintTenuringDistribution 打印gc  后survivor 区的年龄分布</title>
						</item>
						<item type="dict">
							<title type="str">xmx xms设定要相同,每次申请内存之前,实际上都是需要Full GC  的</title>
						</item>
						<item type="dict">
							<title type="str">-XX:+HeapDumpOnOutOfMemoryError  在发生OOM时 生成 dump文件</title>
						</item>
						<item type="dict">
							<title type="str">-XX:+DisableExplictitGC  禁用 System.gc()</title>
						</item>
						<item type="dict">
							<title type="str">元数据优化</title>
							<topics type="list">
								<item type="dict">
									<title type="str">-XX:+MaxMetaspaceSize  最大空间</title>
								</item>
								<item type="dict">
									<title type="str">-XX:+MetaspaceSize  初始空间</title>
								</item>
								<item type="dict">
									<title type="str">-XX:+MinMetaspaceFreeRatio 扩大空间的最小阈值比例</title>
								</item>
								<item type="dict">
									<title type="str">-XX:+MaxMetaspaceFreeRatio 缩小空间的最大阈值比例</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">ParallecGCThreads</title>
							<topics type="list">
								<item type="dict">
									<title type="str">ParNew gc 时的线程数, 一般设置cpu 核数就可以</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">CMS</title>
							<topics type="list">
								<item type="dict">
									<title type="str">-XX:+UseConcMarkSweepGC</title>
									<topics type="list">
										<item type="dict">
											<title type="str">使用 CMS 回收老年代</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">再次标记前minor gc 一次,减少新生代对象大小,减少遍历时间 -XX:+CMSScavengeBeforeRemark</title>
								</item>
								<item type="dict">
									<title type="str">-XX:CMSFullGCsBeforeCompaction=n</title>
									<topics type="list">
										<item type="dict">
											<title type="str">指发生多少次Full gc  才开启压缩 默认是0, 即每次Full gc 后都会压缩</title>
										</item>
										<item type="dict">
											<title type="str">如果设置过高,会导致内存碎片问题严重,多次 Full GC 后也无法压缩</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">-XX:CMSInitiatingOccupancyFraction=70</title>
									<topics type="list">
										<item type="dict">
											<title type="str">CMS在对内存占用率达到70%的时候开始GC</title>
										</item>
										<item type="dict">
											<title type="str">如果内存增长过快,可以适度降低该值,减少 GC 期间,内存不够的问题</title>
										</item>
										<item type="dict">
											<title type="str">如果内存增长缓慢,可以考虑将该值设置高一点, 减少 CMS gc频率</title>
										</item>
										<item type="dict">
											<title type="str">确认是否需要提升老年代空间大小 否则该问题会一直很严重</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">ParallecCMSThreads</title>
									<topics type="list">
										<item type="dict">
											<title type="str">CMS gc时指定的线程核数</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">-XX:+-XX:+PrintGC	</title>
							<topics type="list">
								<item type="dict">
									<title type="str">详细的GC日志</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">停顿时间</title>
							<topics type="list">
								<item type="dict">
									<title type="str">-XX:+PrintGCApplicationStoppedTime</title>
									<topics type="list">
										<item type="dict">
											<title type="str">打印垃圾回收期间程序暂停的时间</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">-XX:+PrintGCApplicationConcurrentTime	</title>
									<topics type="list">
										<item type="dict">
											<title type="str">打印每次垃圾回收前，程序未中断的执行时间</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">-XX:+PrintTLAB	</title>
							<topics type="list">
								<item type="dict">
									<title type="str">打印  线程在eden 分配独有空间的大小</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">-XX:+HeapDumpOnOutOfMemoryError	</title>
							<topics type="list">
								<item type="dict">
									<title type="str">OOM时打印堆栈信息</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">-XX:+PrintClassHistogramBeforeFullGC	
-XX:+PrintClassHistogramBeforeFullGC	</title>
							<topics type="list">
								<item type="dict">
									<title type="str">Full gc前后打印类的柱状信息</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">docker 情况下, 由于获取的核数默认为物理机核数,所以需要手动设置 并行垃圾回收器的线程数</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">zstack 优化</title>
					<topics type="list">
						<item type="dict">
							<title type="str">调大堆内存</title>
							<topics type="list">
								<item type="dict">
									<title type="str">禁止运行时获取内存</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">将老年代比例降下来</title>
							<topics type="list">
								<item type="dict">
									<title type="str">增加新生代的比例,这样让minor gc 减少,减少minor gc,冲向 老年代的对象就少很多</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">子主题 3</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">问题</title>
					<topics type="list">
						<item type="dict">
							<title type="str">promotion failed
会发生Full GC </title>
							<topics type="list">
								<item type="dict">
									<title type="str">1. 救助空间不够，救助空间里的对象还不应该被移动到年老代，但年轻代又有很多对象需要放入救助空间；</title>
								</item>
								<item type="dict">
									<title type="str">2. 年老代没有足够的空间接纳来自年轻代的对象；这两种情况都会转向Full GC</title>
								</item>
								<item type="dict">
									<title type="str">3.应该说该问题和 CMS没有关系,这是新生代gc 时发生的问题,cms 老年代GC时,出现提升失败一般会报 concurrent mode failure</title>
								</item>
								<item type="dict">
									<title type="str">问题根源</title>
									<topics type="list">
										<item type="dict">
											<title type="str">老年代空间确实不够用</title>
										</item>
										<item type="dict">
											<title type="str">老年代内存碎片严重,没有完整空间存放该对象</title>
											<topics type="list">
												<item type="dict">
													<title type="str">CMSFullGCsBeforeCompaction 不要设置过大,会导致多次Full GC 才压缩</title>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">可能是新生代提升过快?是不是survior空间太小,调大试试?</title>
										</item>
										<item type="dict">
											<title type="str">-XX:CMSInitiatingOccupancyFraction过高, 老年代为新生代担保的剩余空间不足</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">concurrent mode failure</title>
							<topics type="list">
								<item type="dict">
									<title type="str">CMS GC 期间,提升对象时(ygc 或大对象)老年代空间不足</title>
									<topics type="list">
										<item type="dict">
											<title type="str">会使用串行收集器收集老年代垃圾</title>
										</item>
									</topics>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">promotion failed – concurrent mode failure
Minor GC后， Survivor空间容纳不了剩余对象，将要放入老年代，老年代有碎片或者不能容纳这些对象，就产生了concurrent mode failure, 然后进行stop-the-world的Serial Old收集器。</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">Full GC</title>
					<topics type="list">
						<item type="dict">
							<title type="str">步骤</title>
							<topics type="list">
								<item type="dict">
									<title type="str">新生代的 GC算法对新生代 GC</title>
								</item>
								<item type="dict">
									<title type="str">老年代的 GC算法对老年代,永久代gc</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">发生条件</title>
							<topics type="list">
								<item type="dict">
									<title type="str">system.gc();</title>
								</item>
								<item type="dict">
									<title type="str">旧生代空间不足</title>
									<topics type="list">
										<item type="dict">
											<title type="str">新生代对象转入</title>
										</item>
										<item type="dict">
											<title type="str">创建为大对象、大数组时</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">. Permanet Generation空间满</title>
									<topics type="list">
										<item type="dict">
											<title type="str">可使用 CMS GC</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">CMS时异常</title>
									<topics type="list">
										<item type="dict">
											<title type="str">promotion failed</title>
											<topics type="list">
												<item type="dict">
													<title type="str">新生代往老年代提升时</title>
													<topics type="list">
														<item type="dict">
															<title type="str">正常年龄足够</title>
														</item>
														<item type="dict">
															<title type="str">survivor 不足,直接提升老年代</title>
														</item>
													</topics>
												</item>
												<item type="dict">
													<title type="str">老年代恰好空间不够</title>
												</item>
												<item type="dict">
													<title type="str">应对措施</title>
													<topics type="list">
														<item type="dict">
															<title type="str">增大survivor space</title>
														</item>
														<item type="dict">
															<title type="str">增大旧生代空间</title>
														</item>
														<item type="dict">
															<title type="str">调低触发并发GC的比率</title>
															<topics type="list">
																<item type="dict">
																	<title type="str">到达该比率 CMS会开启垃圾回收,这样老年代空间会空闲较多</title>
																</item>
															</topics>
														</item>
													</topics>
												</item>
											</topics>
										</item>
										<item type="dict">
											<title type="str">concurrent mode failure</title>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">统计异常</title>
									<topics type="list">
										<item type="dict">
											<title type="str">统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</title>
											<topics type="list">
												<item type="dict">
													<title type="str">此时不会使用新生代 GC方式去回收新生代,而是使用老年代方式回收新生代,老年代,永久代</title>
												</item>
											</topics>
										</item>
									</topics>
								</item>
								<item type="dict">
									<title type="str">实际上除了 CMS, G1其他老年代gc 算法,都会在老年代gc 时,触发Full gc </title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">失败</title>
							<topics type="list">
								<item type="dict">
									<title type="str">如果以上老年代,永久代触发的Full GC 后,分配空间再失败就会报以下异常</title>
								</item>
								<item type="dict">
									<title type="str">：java.lang.OutOfMemoryError: Java heap space</title>
								</item>
								<item type="dict">
									<title type="str">java.lang.OutOfMemoryError: PermGen space</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">serail Old GC</title>
							<topics type="list">
								<item type="dict">
									<title type="str">单线程回收</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">minor gc</title>
					<topics type="list">
						<item type="dict">
							<title type="str">会stop the world</title>
							<topics type="list">
								<item type="dict">
									<title type="str">如果eden大部分对象朝生夕死时间比较短,但是如果大量存活对象,就会很慢</title>
								</item>
								<item type="dict">
									<title type="str">minor gc  的耗时主要在复制对象的时间上</title>
								</item>
								<item type="dict">
									<title type="str">minor gc 时,老年代是不会增长的, 如果老年代引用了新生代,其实也算是新生代 的对象被root根引用了,这样反向引用会导致大量新生代对象被引用,在某些长任务的进程里,会有很多对象引用进老年代

一般情况是,新生代对象引用老年代对象,例如一个普通对象引用了service,dao等常见组件等,这样新生代向老年代的引用会被忽略掉</title>
								</item>
							</topics>
						</item>
						<item type="dict">
							<title type="str">eden Survivor from to</title>
						</item>
						<item type="dict">
							<title type="str">使用标记复制,每一次minor gc eden 区都会被 clear ,eden区每次内存分配都从顶部开始</title>
						</item>
						<item type="dict">
							<title type="str">minor gc将eden区及from survivor区域的存活对象进行处理
如果这些对象年龄达到阈值，则直接晋升到年老代
若要拷贝的对象太大，那么不会拷贝到to survivor，而是直接进入年老代
若to survivor区域空间不够/或者复制过程中出现不够，则发生survivor溢出，直接进入年老代
其他的，若to survivor区域空间够，则存活对象拷贝到to survivor区域</title>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">日志</title>
					<topics type="list">
						<item type="dict">
							<title type="str">-Xloggc:logs/gclog.%p -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=50M -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps</title>
						</item>
						<item type="dict">
							<title type="str">gc real time 才是实际的cpu 耗时</title>
							<topics type="list">
								<item type="dict">
									<title type="str">

    The sys and user are CPU times exclusively. Consequently they do not include the time that the process is blocked for CPU or is doing I/O etc.
    The GC time should generally be similar to the sys+user time but if the process is blocked or waiting then it would be higher. This would be true for a serial collector and a single processor box. However, in the multiprocessor environments (with parallel collectors), the GC time would be lesser than the sys+user time since there are multiple CPUs.
    The real time would be similar to the GC time.

</title>
								</item>
							</topics>
						</item>
					</topics>
				</item>
				<item type="dict">
					<title type="str">[Image]</title>
				</item>
			</topics>
		</topic>
		<structure type="str">org.xmind.ui.map.unbalanced</structure>
	</item>
</root>
